WEBVTT

00:00:00.000 --> 00:00:13.200
This is Hacker Public Radio Episode 4572, for 2026-02-10

00:00:13.200 --> 00:00:16.400
Today's show is entitled, "Uncommon Commands, Episode 3 - strace"

00:00:16.400 --> 00:00:20.040
The host is Deltaray and the duration is 00:17:01

00:00:20.040 --> 00:00:22.080
The flag is Clean, and the license is CC-BY-SA

00:00:22.080 --> 00:00:27.320
The summary is "An overview of how to run and read the output of the strace command."

00:00:40.000 --> 00:00:46.740
Hello everybody and welcome to Hacker Public Radio. This is Delta Ray before I explain anything today

00:00:46.740 --> 00:00:52.360
I want you to actually see something if you're at a Linux system right now or can be later

00:00:52.360 --> 00:01:02.160
Try this simple command in the shell S trace space up time. That's S T R A C E space U P T I M E

00:01:03.160 --> 00:01:07.560
So you run that and just run it once and let the output scroll by

00:01:07.560 --> 00:01:15.120
If this is your first time seeing S trace the output probably looks a little like the matrix

00:01:15.120 --> 00:01:23.880
You know the code that goes by on the screens there. It's a lot of text. There's some weird function names and numbers and hex codes everywhere

00:01:23.880 --> 00:01:28.640
And if your first instinct is wow, I have no idea what I'm looking at

00:01:28.640 --> 00:01:33.600
That's completely normal and probably what has put off most people from learning the command

00:01:33.600 --> 00:01:39.080
But here's the important thing. You don't need to understand everything to start learning from it as

00:01:39.720 --> 00:01:43.080
Uptime runs look near the bottom of the output

00:01:44.000 --> 00:01:51.680
You'll likely see references to files like slash at C slash local time and slash proc slash up time

00:01:52.240 --> 00:01:58.520
Those should already feel a little familiar slash out at C slash local time tells the program

00:01:58.880 --> 00:02:06.480
What time zone the system is in and slash proc slash up time is where the kernel exposes how long the system has been running

00:02:07.000 --> 00:02:12.240
So even though the output looks a bit overwhelming you can already see okay

00:02:12.240 --> 00:02:19.280
This program is reading some files. I recognize now look for a line that includes something like right

00:02:19.640 --> 00:02:28.480
W-R-I-T-E and then parentheses the number one comma and then the string that normally gets print out from the

00:02:28.520 --> 00:02:33.320
Uptime command. This is probably it depends on you know how long your system has actually been up

00:02:33.320 --> 00:02:35.320
But it might have like a

00:02:35.320 --> 00:02:42.640
A laps time like hours min seconds followed by days maybe how many users are logged in and load average

00:02:43.240 --> 00:02:50.720
But that right call is where uptime actually prints the text that you actually see on your screen when you run the uptime command

00:02:51.280 --> 00:02:57.440
The one that's after the parentheses there is the file descriptor number for standard output

00:02:57.520 --> 00:03:05.720
Standard output, you know, it means we're to print the output to the place the program will started from in this case the terminal window

00:03:06.920 --> 00:03:10.720
So uptime isn't magically printing text it's explicitly

00:03:10.720 --> 00:03:16.080
Asking the kernel please write these bytes to standard out and the kernel does exactly that

00:03:16.880 --> 00:03:19.680
This is the key thing I want you to notice right away

00:03:19.680 --> 00:03:25.960
S trace isn't magic it's simply showing you the conversation between a program in the operating system

00:03:26.440 --> 00:03:29.960
files get opened data gets red text gets written

00:03:30.440 --> 00:03:35.560
Once you see that the output starts to feel a little less intimidating and it's core

00:03:35.880 --> 00:03:37.880
Estrace just shows system calls

00:03:38.680 --> 00:03:42.040
System calls are how user space programs talk to the kernel

00:03:42.520 --> 00:03:50.320
User space programs being the programs that you normally run when you run your system and the kernel being the back end brain for the operating system

00:03:50.320 --> 00:03:52.320
That actually talks to the hardware

00:03:52.560 --> 00:03:59.280
Anytime a program opens a file reads data writes output talks to the network creates a process

00:03:59.760 --> 00:04:04.800
It has to ask the kernel to do that work because the kernel is what talks to the hardware

00:04:05.600 --> 00:04:07.600
Estrace just lets you listen in

00:04:08.080 --> 00:04:14.480
It's very similar to a program like TCP dump or wire shark if you've ever used that to listen to the network

00:04:15.200 --> 00:04:20.760
Let me give you a real example of where estrace earned its keep early in my system administration career

00:04:21.000 --> 00:04:26.520
I forced myself to get comfortable reading estrace output because I saw other system administrators using it

00:04:27.080 --> 00:04:36.040
Not memorizing everything about it, but just learning how to recognize patterns some of the basic system calls and how the output for those system calls was presented

00:04:36.600 --> 00:04:40.680
I used it occasionally for myself to find out why something was not working for me

00:04:40.840 --> 00:04:47.640
But the real place where it's shined was later when I was working as a Linux system administrator at a mid-sized enterprise company

00:04:48.120 --> 00:04:54.680
And we had this commercially developed application that just wouldn't work. It was failing and some weird way

00:04:55.000 --> 00:05:02.000
We were trying to figure out where it was light writing files to the logs were vague the documentation wasn't great

00:05:02.000 --> 00:05:07.800
And nothing obvious was jumping out, so we were just kind of guessing us to what it was doing

00:05:08.640 --> 00:05:15.600
The other system administrators had theory they suspected the program was trying to read from or write to some directory

00:05:15.600 --> 00:05:17.600
It didn't have access to

00:05:17.600 --> 00:05:25.420
But that was about all it was a theory. We didn't have any way of proving it and the application certainly wasn't volunteering that information

00:05:25.920 --> 00:05:34.680
This is where I suggested using estrace. I sat down sshed in to the system and ran estrace on the already running process

00:05:34.680 --> 00:05:39.840
Just grabbing its PID its process ID and traced it live within seconds

00:05:40.080 --> 00:05:46.560
There it was in black and white the program was trying to write a file to a specific directory and then read it back

00:05:46.560 --> 00:05:49.520
And the directory had the wrong permissions on it

00:05:49.520 --> 00:05:53.520
So there was no guess work, no assumptions. It just gave us evidence

00:05:53.840 --> 00:05:59.120
What was funny was the reaction from the other system administrators the other admins were kind of stunned

00:05:59.520 --> 00:06:05.680
They hadn't realized you could attach to a running process like that and just watch what it was doing at the system level

00:06:05.840 --> 00:06:09.400
It was like I'd cast some magic spell or hack the system

00:06:09.680 --> 00:06:14.120
This was one of those moments. I realized that I could create the CLI magic feed

00:06:14.840 --> 00:06:20.640
But it wasn't magic. It was just asking the operating system. Hey, what is this program actually doing?

00:06:22.040 --> 00:06:24.840
System calls or how operating systems work?

00:06:25.720 --> 00:06:30.560
There is no deeper hidden layer show commands GUI applications

00:06:30.840 --> 00:06:36.800
Demons containers everything eventually boils down to system calls like open read right

00:06:37.240 --> 00:06:43.720
Stat fork exec fee. There's a whole bunch more out there and there's some newer ones that you might have

00:06:44.120 --> 00:06:47.000
seen in the in the output of S trace

00:06:47.480 --> 00:06:53.400
But I'm not going to get into all that essentially if you see something like open or open to or open add

00:06:53.400 --> 00:06:56.760
It's still probably reading a file or opening a file

00:06:57.440 --> 00:07:01.840
So once you internalize that S trace stops being scary and starts being more obvious

00:07:02.680 --> 00:07:11.120
Now let's simplify things further try to running this command S trace space dash e space open at

00:07:11.120 --> 00:07:14.560
So O P E N A T space

00:07:15.280 --> 00:07:16.480
LS

00:07:16.480 --> 00:07:22.760
So you basically running the LS command from S trace so that it all attached to the LS command right away

00:07:23.680 --> 00:07:28.880
The dash e option tells S trace only show me file open relayed system calls

00:07:28.880 --> 00:07:34.760
In other words the open at system call you have to be specific to whatever system call

00:07:34.760 --> 00:07:40.880
You're trying to actually filter out this cuts down on the noise quite a bit as it's only gonna show you

00:07:40.960 --> 00:07:42.960
The open add functions

00:07:43.360 --> 00:07:50.320
So instead of thousands of lines of output you'll see a short list showing which files LS asks the kernel to open

00:07:51.040 --> 00:07:54.160
You might see something like open at

00:07:54.160 --> 00:07:55.440
AT

00:07:55.440 --> 00:07:57.440
Fd CWD

00:07:57.440 --> 00:07:58.640
O

00:07:58.640 --> 00:08:00.640
Rd only oh

00:08:00.640 --> 00:08:07.040
Directory equals three and you know a lot of that stuff. I mean, I you know, I can't really read it

00:08:07.440 --> 00:08:13.120
But you can kind of get it's to it's talking about you know read only access maybe and and

00:08:14.080 --> 00:08:18.640
A directory or something and CWD might mean current working directory

00:08:18.960 --> 00:08:24.320
But that's not what really matters here the equals three at the end is probably the most important part

00:08:25.600 --> 00:08:32.000
You don't need to understand everything here just a few pieces so open at is the system call the dot

00:08:32.560 --> 00:08:38.640
That's in the middle of the system call is just the path that's being opened so the dot meaning the current

00:08:39.040 --> 00:08:44.400
Directory that you're in and the equals three at the end is the file descriptor that's returned by the kernel

00:08:45.120 --> 00:08:49.120
If you're not familiar with programming and file descriptors don't worry too much about that

00:08:49.120 --> 00:08:56.480
It's basically just a way of referencing the file like the data that it's accessing

00:08:56.880 --> 00:08:59.520
So in this case, it's assigning it to the number three

00:09:00.320 --> 00:09:03.280
File descriptors are are just usually small integers

00:09:03.920 --> 00:09:09.840
You'll see something like zero for standard input one for standard output and two for standard error

00:09:10.240 --> 00:09:15.840
So when you see something like three four five those are additional files the program is opened

00:09:16.080 --> 00:09:19.280
In this case three being the current directory that you're in

00:09:20.320 --> 00:09:25.360
If the program that you're running happened to open up more files those numbers would increase more

00:09:25.840 --> 00:09:31.280
But it's important to note that those numbers might need to be referenced later if you're looking at a more

00:09:31.600 --> 00:09:34.960
Sophisticated S trace output of a of a bigger program

00:09:35.360 --> 00:09:43.280
You might have to keep track of those numbers so that you can see where it actually reads from a file that opens and so on

00:09:43.600 --> 00:09:46.320
So those numbers can help you figure those things out

00:09:47.600 --> 00:09:53.680
Now let's try something that doesn't exist if you run S trace space dash e

00:09:54.640 --> 00:10:03.440
Open at space LS and then it doesn't matter which put here maybe just put in slash does slash not slash exist

00:10:04.240 --> 00:10:12.960
And you'll see something like open at followed by you know those those capital letter flags and then the path that you actually tried to

00:10:14.080 --> 00:10:21.280
Open or list and you know does not exist and then the important part is at the end the negative one

00:10:21.840 --> 00:10:28.000
ENO ENT that's incredibly useful. It's it's the kernel is telling you very plainly

00:10:28.320 --> 00:10:34.080
I was asked to open a file and it does not exist so there's no guessing or mystery you can see right there

00:10:34.720 --> 00:10:38.480
What the the output error code was from the kernel

00:10:40.080 --> 00:10:45.440
If you later read uh if you later trace the read calls you'll see lines like read

00:10:46.400 --> 00:10:52.000
Followed by parentheses and then you know the file handle number so maybe it's a three and then

00:10:52.800 --> 00:10:54.800
Some extra arguments to that function

00:10:55.920 --> 00:11:00.480
Followed by a number at the end. It's probably gonna be something like 4,096

00:11:01.040 --> 00:11:04.320
It might be a different power of two but usually it's a power of two

00:11:04.960 --> 00:11:10.720
Unless you're getting to the end of a file and then it might be whatever's left over

00:11:11.440 --> 00:11:17.440
And so after that it's gonna say equals and then the last number is gonna be like 128 or

00:11:17.920 --> 00:11:21.600
Something like that and that's how many bytes were actually read in

00:11:22.480 --> 00:11:27.680
On that function call. So that's kind of useful. You can see how many actual bytes of data got read in

00:11:28.320 --> 00:11:31.120
Not how many were requested but how many were returned

00:11:32.240 --> 00:11:38.640
You don't need to master this right now. Just notice how explicit the kernel is being so that you can kind of get a sense of

00:11:39.200 --> 00:11:43.840
Hey, this data is here. I can actually use this later and trying to diagnose a problem

00:11:44.640 --> 00:11:48.560
There's another situation you're running into with strace. That's worth talking about

00:11:49.120 --> 00:11:55.760
Sometimes you attach strace to a process and it just sits there. No scrolling no errors just one line

00:11:55.760 --> 00:12:00.560
Maybe nothing at all and it usually means that it's waiting for something

00:12:00.560 --> 00:12:02.880
So you might see something like read

00:12:03.280 --> 00:12:11.040
Print the seeds three comma something and then 4,96 and then it's just sitting there and it doesn't return a prompt or anything

00:12:11.440 --> 00:12:18.080
That means the program is waiting for input. So the program that it's stracing is waiting for some kind of data to come back

00:12:18.400 --> 00:12:20.800
That could be data from a file from a

00:12:21.360 --> 00:12:24.560
pipe from a socket from another process

00:12:25.120 --> 00:12:28.480
It's not a crash. It's basically just blocking on IO

00:12:29.040 --> 00:12:33.840
Waiting and you know at this point you might just yes say control c

00:12:34.320 --> 00:12:40.000
But it could be that this will tell you you know that some things not what right with the program

00:12:40.000 --> 00:12:43.120
Maybe something's not right with your file system or whatever

00:12:44.000 --> 00:12:48.320
Most definitely if you try to hit control c here and it doesn't give you the prompt backed

00:12:49.360 --> 00:12:55.680
And you can't cancel the strace process which I've run into before you probably do have some kind of problem with

00:12:56.080 --> 00:13:03.360
Your storage device or something and the kernel isn't able to like give you back the data

00:13:04.320 --> 00:13:10.240
The same idea applies to socket relayed calls if a process is just sitting in a network called

00:13:10.240 --> 00:13:15.920
Offemines of swing for the remote service and a connection or data to arrive over the network

00:13:16.240 --> 00:13:18.880
Again, it's not necessarily an error. It's just waiting

00:13:19.840 --> 00:13:28.480
If you attach to if you attach strace and see no system calls happening that often means the program is busy doing work entirely in user space

00:13:28.480 --> 00:13:36.000
Maybe calculations parsing compression, you know something like that until it needs to talk to the kernel again

00:13:36.000 --> 00:13:42.560
There's nothing to show that distinction alone can save you a lot of time because you know, oh, it's actually doing something

00:13:42.560 --> 00:13:48.160
Maybe it's stuck in infinite loop. It's it's hard to know but at least it gives you some kind of information

00:13:49.200 --> 00:13:53.760
One thing that trips people up strace writes it's output to standard error

00:13:54.720 --> 00:14:00.320
Not standard output. So you won't be able to do something like strace space LS pipe

00:14:00.720 --> 00:14:05.440
Grap open. You're not going to actually be able to filter out those open requests that way

00:14:06.240 --> 00:14:09.840
You can fix that by redirecting standard error to standard output

00:14:10.720 --> 00:14:17.920
By using something like strace space LS space two greater than ampersand one which does the

00:14:18.400 --> 00:14:22.960
Redirection and combining was standard output and then pipe that into Grap open

00:14:23.840 --> 00:14:30.400
Or you can have strace right directly to a file which is what I usually do when I'm using strace and there's like a lot of output

00:14:30.880 --> 00:14:36.480
So you use the dash oh option like this strace space dash oh space

00:14:37.040 --> 00:14:44.160
The file that you want to log to so you might call like trace.log space LS or whatever command you want to run

00:14:45.360 --> 00:14:50.640
So that dash oh option is very useful for when you're doing very large traces that you want to look at later

00:14:50.640 --> 00:14:53.520
Maybe in using the less command or something like that

00:14:54.720 --> 00:15:00.960
You can also attach strace to a running process. So for instance if you have like a demon or something like that

00:15:01.040 --> 00:15:11.280
They want to monitor you can use the dash p option so it can be like strace space dash p space the process ID so make you know like one two three four five

00:15:12.080 --> 00:15:17.440
And this lets you see what a program is doing right now as it's running when you're done you can press

00:15:17.440 --> 00:15:23.120
Control c and it detaches strace in the process that you're you're monitoring keeps running in the background

00:15:23.920 --> 00:15:30.400
Many programs also fork off in our words. They copy themselves and memory and make a new process

00:15:30.480 --> 00:15:36.560
In the table and that can become confusing when you try to run strace again something because

00:15:37.040 --> 00:15:41.280
The strace for the initial command will end and you won't actually

00:15:41.680 --> 00:15:50.400
Continue tracing what you forked off and so in that case you need to use some options either dash f or dash f

00:15:51.040 --> 00:15:54.640
In order to start following off the forked processes

00:15:55.120 --> 00:16:02.240
So maybe you're running you know strace space dash f space my server or you know some some server

00:16:02.720 --> 00:16:04.720
Command that you want to start

00:16:04.720 --> 00:16:07.360
If you want to split the output in the separate files

00:16:08.080 --> 00:16:15.120
So that you have an output file, but it creates a new file for every forked off process for instance like a web server

00:16:15.360 --> 00:16:21.440
Does this kind of thing then you would use the dash f f option along with dash o and

00:16:21.520 --> 00:16:28.080
You know the output file that you want and then it'll create a new file with the process ID and it's file name

00:16:28.480 --> 00:16:33.600
For every forked off process so this way if you want to do something like monitor a web server

00:16:33.600 --> 00:16:36.000
You can do that and you'll have a

00:16:36.480 --> 00:16:44.640
Separate trace log for each of the requests that gets made. I've done this several times for for monitoring web servers

00:16:45.600 --> 00:16:52.000
Astrace doesn't just help you debug it also changes your mental model instead of thinking this makes no sense

00:16:52.000 --> 00:16:55.600
You start thinking what is a program asking the kernel to do?

00:16:55.840 --> 00:17:01.200
You know behind each of those buttons in a gooey application and behind every one of those commands that you're

00:17:01.760 --> 00:17:08.240
Running our system calls that are getting made to the kernel to do different things and that shift makes

00:17:09.200 --> 00:17:15.840
Debugging comma more mechanical and much less emotional, you know, you're going to have a process to doing it

00:17:16.480 --> 00:17:20.800
So if strace feels like black magic right now, that's normal

00:17:21.520 --> 00:17:23.920
But it isn't magic it's literacy and

00:17:24.080 --> 00:17:29.040
Once you have it you'll start seeing problems not as mysteries but as conversations between

00:17:29.360 --> 00:17:32.320
Program and the kernel that you can finally listen to

00:17:32.800 --> 00:17:35.840
Thanks for listening and as always welcome to hacker public radio

00:17:35.840 --> 00:17:41.120
I hope that you take the time to actually record an episode in the future take care so long

00:17:41.000 --> 00:17:48.720
You have been listening to Hacker Public Radio at Hacker Public Radio.org.

00:17:48.720 --> 00:17:52.520
Today's show was contributed by a HPR listener like yourself.

00:17:52.520 --> 00:17:59.000
If you ever thought of recording podcast, click on our upload link

00:17:59.000 --> 00:18:00.000
to find out how easy it is.

00:18:00.000 --> 00:18:07.480
Hosting for HPR has been kindly provided by an AnHonestHost.com, the Internet Archive,

00:18:07.480 --> 00:18:08.480
rsync.net, and our mirror network.

00:18:08.480 --> 00:18:14.480
Unless otherwise stated, today's show is released under a Creative Commons

00:18:14.480 --> 00:18:17.480
Attribution-ShareAlike 4.0 International (CC BY-SA 4.0) license.

